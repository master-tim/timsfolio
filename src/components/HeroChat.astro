---
---

<!-- Regular Chat Widget -->
<div class="relative w-full max-w-md mx-auto mt-8 md:mt-0 reveal-on-scroll">
  <!-- Chat Container -->
  <div id="chat-widget" class="bg-white border-2 border-black shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] p-6 rounded-lg relative z-10 transition-opacity duration-300">
    <!-- Header -->
    <div class="flex items-center gap-3 mb-4 border-b-2 border-black pb-2">
      <button id="btn-reset" class="w-3 h-3 rounded-full bg-red-500 border border-black hover:scale-110 transition-transform cursor-pointer" aria-label="Reset Chat"></button>
      <button id="btn-disable" class="w-3 h-3 rounded-full bg-yellow-500 border border-black hover:scale-110 transition-transform cursor-pointer" aria-label="Disable Input"></button>
      <button id="btn-expand" class="w-3 h-3 rounded-full bg-green-500 border border-black hover:scale-110 transition-transform cursor-pointer" aria-label="Fullscreen"></button>
      <button id="fullscreen-btn" class="ml-auto px-3 py-1 bg-pblue text-white hover:bg-pblue/90 border-2 border-black rounded text-xs font-bold transition font-mono">
        ▲ Fullscreen
      </button>
    </div>

    <!-- Chat History / Output -->
    <div id="chat-output" class="hidden min-h-[150px] max-h-[250px] overflow-y-auto mb-4 font-mono text-sm space-y-3 bg-gray-50 p-2 border-2 border-black rounded">
      <div class="text-pblack/70 hidden sm:block">
        > Ask me anything about Tim's experience, skills, or projects.
      </div>
    </div>

    <!-- Input Area -->
    <form id="chat-form" class="flex flex-col sm:flex-row gap-2">
      <input 
        type="text" 
        id="chat-input" 
        placeholder="e.g., Does Tim know React?" 
        class="flex-1 bg-white border-2 border-black px-3 py-2 text-sm focus:outline-none focus:shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] transition-all font-mono"
        required
      />
      <button 
        type="submit" 
        class="bg-pblue text-white border-2 border-black px-4 py-2 text-sm font-bold hover:translate-y-[-2px] hover:shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] active:translate-y-[0px] active:shadow-none transition-all font-mono w-full sm:w-auto"
      >
        ASK
      </button>
    </form>

    <!-- Suggestions -->
    <div class="flex gap-2 mt-3 overflow-x-auto pb-1 no-scrollbar">
      <button type="button" class="suggestion-btn text-xs bg-gray-100 px-2 py-1 rounded border border-black hover:bg-gray-200 transition whitespace-nowrap font-mono">Tell me about Temirlan's skills</button>
      <button type="button" class="suggestion-btn text-xs bg-gray-100 px-2 py-1 rounded border border-black hover:bg-gray-200 transition whitespace-nowrap font-mono">What is his experience with AI?</button>
    </div>
    
    <div class="mt-2 text-[10px] text-gray-400 text-center font-mono">
      * AI can make mistakes. Please verify important info.
    </div>
  </div>

  <!-- Decorative Background Element -->
  <div class="absolute -top-4 -right-4 w-full h-full bg-ppink border-2 border-black rounded-lg -z-10"></div>
</div>

<script>
  import { marked } from 'marked';

  function initChat() {
    // Elements
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('chat-input');
    const output = document.getElementById('chat-output');
    const suggestionBtns = document.querySelectorAll('.suggestion-btn');

    if (!form || !input || !output) {
      // console.error('Chat elements not found'); // Silent fail if not on page
      return;
    }

    // Create fullscreen modal and append to body
    const modalBackdrop = document.createElement('div');
    modalBackdrop.id = 'chat-modal-backdrop';
    modalBackdrop.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 9999; display: none; align-items: center; justify-content: center; padding: 1rem;';
    
    modalBackdrop.innerHTML = `
      <div id="modal-container" style="position: relative; width: 100%; max-width: 56rem; height: 80vh; transform: scale(0.8); opacity: 0; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">
        <div class="bg-white border-2 border-black shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] p-6 rounded-lg h-full flex flex-col">
          <!-- Header -->
          <div class="flex items-center gap-3 mb-4 border-b-2 border-black pb-2">
            <button class="btn-minimize w-3 h-3 rounded-full bg-red-500 border border-black hover:scale-110 transition-transform cursor-pointer"></button>
            <button class="btn-minimize w-3 h-3 rounded-full bg-yellow-500 border border-black hover:scale-110 transition-transform cursor-pointer"></button>
            <button class="btn-minimize w-3 h-3 rounded-full bg-green-500 border border-black hover:scale-110 transition-transform cursor-pointer"></button>
            <span class="ml-auto font-mono text-xs font-bold text-pgreen">AI_ASSISTANT.exe</span>
            <button id="minimize-btn" class="ml-2 px-3 py-1 bg-gray-200 hover:bg-gray-300 border-2 border-black rounded text-xs font-bold transition">
              ▼ Minimize
            </button>
          </div>

          <!-- Chat History / Output (Fullscreen) -->
          <div id="chat-output-fullscreen" class="flex-1 overflow-y-auto mb-4 font-mono text-sm space-y-3 bg-gray-50 p-4 border-2 border-black rounded">
            <div class="text-pblack/70">
              > Ask me anything about Tim's experience, skills, or projects.
            </div>
          </div>

          <!-- Input Area -->
          <form id="chat-form-fullscreen" class="flex gap-2">
            <input 
              type="text" 
              id="chat-input-fullscreen" 
              placeholder="e.g., Does Tim know React?" 
              class="flex-1 bg-white border-2 border-black px-3 py-2 text-sm focus:outline-none focus:shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] transition-all font-mono"
              required
            />
            <button 
              type="submit" 
              class="bg-pblue text-white border-2 border-black px-4 py-2 text-sm font-bold hover:translate-y-[-2px] hover:shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] active:translate-y-[0px] active:shadow-none transition-all font-mono"
            >
              ASK
            </button>
          </form>

          <!-- Suggestions -->
          <div class="flex gap-2 mt-3 overflow-x-auto pb-1 no-scrollbar">
            <button type="button" class="suggestion-btn-fullscreen text-xs bg-gray-100 px-2 py-1 rounded border border-black hover:bg-gray-200 transition whitespace-nowrap font-mono">Tell me about Temirlan's skills</button>
            <button type="button" class="suggestion-btn-fullscreen text-xs bg-gray-100 px-2 py-1 rounded border border-black hover:bg-gray-200 transition whitespace-nowrap font-mono">What is his experience with AI?</button>
          </div>
          
          <div class="mt-2 text-[10px] text-gray-400 text-center font-mono">
            * AI can make mistakes. Please verify important info.
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modalBackdrop);

    // Get fullscreen elements after appending
    const minimizeBtn = document.getElementById('minimize-btn');
    const formFullscreen = document.getElementById('chat-form-fullscreen');
    const inputFullscreen = document.getElementById('chat-input-fullscreen');
    const outputFullscreen = document.getElementById('chat-output-fullscreen');
    const suggestionBtnsFullscreen = document.querySelectorAll('.suggestion-btn-fullscreen');

    // Get modal container for animations
    const modalContainer = document.getElementById('modal-container');
    const chatContainer = output.closest('.bg-white');
    const chatWidget = document.getElementById('chat-widget');

    // Fullscreen toggle with morphing animation
    fullscreenBtn.addEventListener('click', function() {
      // Get the position and size of the original chat box
      const rect = chatContainer.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      // Calculate the scale needed to transform from small to large
      const scaleX = rect.width / (Math.min(56 * 16, windowWidth - 32)); // 56rem = 896px max
      const scaleY = rect.height / (windowHeight * 0.8);
      
      // Calculate the translation needed
      const centerX = windowWidth / 2;
      const centerY = windowHeight / 2;
      const boxCenterX = rect.left + rect.width / 2;
      const boxCenterY = rect.top + rect.height / 2;
      const translateX = boxCenterX - centerX;
      const translateY = boxCenterY - centerY;
      
      // Set initial state (at widget position)
      modalContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
      modalContainer.style.opacity = '1';
      
      // Fade out the original widget
      chatWidget.style.opacity = '0';
      
      // Show modal
      modalBackdrop.style.display = 'flex';
      outputFullscreen.innerHTML = output.innerHTML;
      document.body.style.overflow = 'hidden';
      
      // Animate to fullscreen position
      setTimeout(() => {
        modalContainer.style.transform = 'translate(0, 0) scale(1, 1)';
      }, 10);
    });

    minimizeBtn.addEventListener('click', function() {
      // Get current position of chat box
      const rect = chatContainer.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      const scaleX = rect.width / (Math.min(56 * 16, windowWidth - 32));
      const scaleY = rect.height / (windowHeight * 0.8);
      
      const centerX = windowWidth / 2;
      const centerY = windowHeight / 2;
      const boxCenterX = rect.left + rect.width / 2;
      const boxCenterY = rect.top + rect.height / 2;
      const translateX = boxCenterX - centerX;
      const translateY = boxCenterY - centerY;
      
      // Animate back to widget position
      modalContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
      
      // Wait for animation, then hide
      setTimeout(() => {
        modalBackdrop.style.display = 'none';
        output.innerHTML = outputFullscreen.innerHTML;
        document.body.style.overflow = '';
        // Reset transform for next open
        modalContainer.style.transform = 'translate(0, 0) scale(1, 1)';
        // Fade the widget back in
        chatWidget.style.opacity = '1';
      }, 300);
    });

    // Close on backdrop click
    modalBackdrop.addEventListener('click', function(e) {
      if (e.target === modalBackdrop) {
        minimizeBtn.click();
      }
    });

    // Handle Suggestions (Regular)
    suggestionBtns.forEach(function(btn) {
      btn.addEventListener('click', function() {
        input.value = btn.textContent || '';
        input.focus();
      });
    });

    // Handle Suggestions (Fullscreen)
    suggestionBtnsFullscreen.forEach(function(btn) {
      btn.addEventListener('click', function() {
        inputFullscreen.value = btn.textContent || '';
        inputFullscreen.focus();
      });
    });

    // --- Traffic Light Buttons Logic ---

    // 1. Regular Mode Buttons
    const btnReset = document.getElementById('btn-reset');
    const btnDisable = document.getElementById('btn-disable');
    const btnExpand = document.getElementById('btn-expand');

    // Green: Fullscreen
    if (btnExpand) {
      btnExpand.addEventListener('click', () => {
        fullscreenBtn.click();
      });
    }

    // Red: Reset Chat
    if (btnReset) {
      btnReset.addEventListener('click', () => {
        // Clear output except the initial message
        output.innerHTML = `
          <div class="text-pblack/70 hidden sm:block">
            > Ask me anything about Tim's experience, skills, or projects.
          </div>
        `;
        // Clear input
        input.value = '';
        input.disabled = false;
        input.focus();
        
        // Also reset fullscreen output if it exists
        if (outputFullscreen) {
           outputFullscreen.innerHTML = `
            <div class="text-pblack/70">
              > Ask me anything about Tim's experience, skills, or projects.
            </div>
          `;
        }
      });
    }

    // Yellow: Disable/Enable Input
    if (btnDisable) {
      btnDisable.addEventListener('click', () => {
        input.disabled = !input.disabled;
        if (input.disabled) {
          input.placeholder = "Input disabled...";
          input.classList.add('bg-gray-100', 'cursor-not-allowed');
        } else {
          input.placeholder = "e.g., Does Tim know React?";
          input.classList.remove('bg-gray-100', 'cursor-not-allowed');
          input.focus();
        }
      });
    }

    // 2. Fullscreen Mode Buttons (All act as minimize)
    const minimizeBtns = modalBackdrop.querySelectorAll('.btn-minimize');
    minimizeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        minimizeBtn.click();
      });
    });

    // Setup chat for regular view
    setupChatForm(form, input, output);
    
    // Setup chat for fullscreen view
    setupChatForm(formFullscreen, inputFullscreen, outputFullscreen);

    function setupChatForm(formEl, inputEl, outputEl) {
      formEl.addEventListener('submit', async function(e) {
        e.preventDefault();
        const message = inputEl.value.trim();
        if (!message) return;

        // Check if first message
        const isFirstMessage = outputEl.classList.contains('hidden');
        
        if (isFirstMessage) {
          // First message flow: open fullscreen immediately
          if (outputEl === output) {
            // Unhide the output first
            outputEl.classList.remove('hidden');
            
            // Trigger fullscreen which will sync content
            fullscreenBtn.click();
            
            // Wait a tiny bit for fullscreen to open, then add message to fullscreen view
            setTimeout(() => {
              appendMessage(outputFullscreen, 'User', message, 'text-pblue font-bold');
              inputFullscreen.value = '';
              inputFullscreen.disabled = true;
              
              // Add loading to fullscreen
              const loadingId = 'loading-' + Date.now();
              const loadingDiv = document.createElement('div');
              loadingDiv.id = loadingId;
              loadingDiv.className = "text-gray-500 animate-pulse";
              loadingDiv.innerHTML = "> Thinking...";
              outputFullscreen.appendChild(loadingDiv);
              outputFullscreen.scrollTop = outputFullscreen.scrollHeight;
              
              // Make the API call
              fetchResponse(message, outputFullscreen, inputFullscreen, loadingId);
            }, 350); // Wait for fullscreen animation
            
            // Clear and disable the original input
            inputEl.value = '';
            inputEl.disabled = true;
            return;
          }
        }

        // Normal flow (not first message or already in fullscreen)
        appendMessage(outputEl, 'User', message, 'text-pblue font-bold');
        inputEl.value = '';
        inputEl.disabled = true;

        // Add Loading Indicator
        const loadingId = 'loading-' + Date.now();
        const loadingDiv = document.createElement('div');
        loadingDiv.id = loadingId;
        loadingDiv.className = "text-gray-500 animate-pulse";
        loadingDiv.innerHTML = "> Thinking...";
        outputEl.appendChild(loadingDiv);
        outputEl.scrollTop = outputEl.scrollHeight;

        // Make the API call
        fetchResponse(message, outputEl, inputEl, loadingId);
      });
      
      // Extracted fetch response function
      async function fetchResponse(message, outputEl, inputEl, loadingId) {
        try {
          const res = await fetch('/api/stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: message }),
          });

          // Remove loading
          const loadingEl = document.getElementById(loadingId);
          if (loadingEl) loadingEl.remove();

          if (!res.ok) throw new Error(res.statusText);

          // Create AI message container
          const aiMsgDiv = document.createElement('div');
          aiMsgDiv.className = 'break-words text-pblack';
          aiMsgDiv.innerHTML = '<span class="opacity-50 text-xs uppercase mr-1">[AI]</span> ';
          
          const contentDiv = document.createElement('div');
          contentDiv.className = 'inline-block align-top markdown-content';
          aiMsgDiv.appendChild(contentDiv);
          outputEl.appendChild(aiMsgDiv);

          // Stream reader
          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let fullText = '';
          let isCached = false;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const data = line.slice(6);
                if (data === '[DONE]') break;
                
                try {
                  const parsed = JSON.parse(data);
                  
                  // Check if this is a cache indicator
                  if (parsed.cached === true) {
                    isCached = true;
                    // Add cache badge to AI label
                    const aiLabel = aiMsgDiv.querySelector('span');
                    if (aiLabel) {
                      aiLabel.innerHTML = '[AI] <span class="text-pgreen" title="Response served from cache">⚡</span> ';
                    }
                  }
                  
                  if (parsed.chunk) {
                    fullText += parsed.chunk;
                    // Re-render markdown on every chunk
                    contentDiv.innerHTML = marked.parse(fullText);
                    outputEl.scrollTop = outputEl.scrollHeight;
                    
                    // Sync to other view if needed
                    if (outputEl === output) {
                      outputFullscreen.innerHTML = output.innerHTML;
                    } else {
                      output.innerHTML = outputFullscreen.innerHTML;
                    }
                  }
                } catch (e) {
                  console.error('Error parsing stream:', e);
                }
              }
            }
          }

        } catch (err) {
          const loadingEl = document.getElementById(loadingId);
          if (loadingEl) loadingEl.remove();
          appendMessage(outputEl, 'System', 'Connection Error.', 'text-red-600');
        } finally {
          inputEl.disabled = false;
          inputEl.focus();
        }
      }
    }

    function appendMessage(outputEl, sender, text, className, isMarkdown = false) {
      if (!outputEl) return;

      const div = document.createElement('div');
      div.className = 'break-words ' + className;
      div.innerHTML = '<span class="opacity-50 text-xs uppercase mr-1">[' + sender + ']</span> ';
      
      const contentSpan = document.createElement('div');
      contentSpan.className = 'inline-block align-top markdown-content'; // Use div for block content
      
      if (isMarkdown) {
        // Parse Markdown
        contentSpan.innerHTML = marked.parse(text);
      } else {
        contentSpan.textContent = text;
      }
      
      div.appendChild(contentSpan);
      outputEl.appendChild(div);
      outputEl.scrollTop = outputEl.scrollHeight;
    }
  }

  // Initialize on page load and after view transitions
  document.addEventListener('astro:page-load', initChat);
</script>

<style is:global>
  /* Hide scrollbar for Chrome, Safari and Opera */
  .no-scrollbar::-webkit-scrollbar {
      display: none;
  }
  /* Hide scrollbar for IE, Edge and Firefox */
  .no-scrollbar {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
  }

  /* Markdown Styles for Chat */
  .markdown-content p {
    margin-bottom: 0.5rem;
  }
  .markdown-content p:last-child {
    margin-bottom: 0;
  }
  .markdown-content ul {
    list-style-type: disc;
    padding-left: 1.2rem;
    margin-bottom: 0.5rem;
  }
  .markdown-content ol {
    list-style-type: decimal;
    padding-left: 1.2rem;
    margin-bottom: 0.5rem;
  }
  .markdown-content li {
    margin-bottom: 0.2rem;
  }
  .markdown-content strong {
    font-weight: bold;
  }
  .markdown-content em {
    font-style: italic;
  }
  .markdown-content code {
    background-color: #f3f4f6;
    padding: 0.1rem 0.3rem;
    border-radius: 0.2rem;
    font-family: monospace;
    font-size: 0.9em;
  }
</style>
